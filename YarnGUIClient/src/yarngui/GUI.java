
package yarngui;

import java.awt.Component;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.WindowEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.*;
import java.net.URL;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import sun.audio.*;

/**
 * This class is responsible for providing a sub class of JFrame which is used 
 * as the main GUI interface dialog.  This dialog is launched when the client 
 * application is executed.  All user interactions are performed through this 
 * dialog window.  This dialog window allows a user to connect/disconnect, send 
 * and receive text, initiate data shares and display the current chat text for 
 * the connected clients.  The GUI interface is designed to be simplistic but 
 * functionality with an aim to provide user ease of use through an intuitive 
 * layout.  The GUI dialog was developed using Netbeans Swing.  
 * @author Michael Telford
 */
public class GUI extends JFrame {
    
    private boolean             isConnected         = false;
    private String              lastPMUsernames     = "";
    private String              lastSentText        = "";
    private Connection          connection          = null;
    private PreferencesDialog   preferencesDialog   = null;
    private ShareDialog         shareDialog         = null;
    private ConferenceDialog    conferenceDialog    = null;
    
    /**
     * Constructor for the main GUI dialog window responsible for initialising 
     * the graphical components, loading the configuration values and displaying 
     * the welcome and help messages to the user.  The main GUI dialog window is 
     * displayed by the main() method not this constructor however.  This 
     * constructor is used only for the initialisation, not the displaying of 
     * the GUI.  
     */
    public GUI(){
        // Load GUI components and configuration values.
        initComponents();
        Configuration.readConfigValues();
        this.connection = new Connection(this);
        // Manually init components.
        JComponent comp = (JComponent) this.getContentPane();
        comp.setBorder(new EmptyBorder(1,1,3,1));
        this.setTitle("Yarn Messenger " + Configuration.VERSION);
        this.setSystemText(Configuration.WELCOME_MSG);
        this.setSystemText("\nType -help (-h) to display this help information :");
        this.setSystemText(Configuration.HELP_MSG);
        this.scrollConferenceToTop();
        this.serverAddress.requestFocus();
        // Init conference dialog.
        this.conferenceDialog = new ConferenceDialog(this);
    }
    
    /**
     * Return method for the connection instance used in order to connect to a 
     * server instance, send text and start the receive thread.  
     * @return The connection instance used for the networking of this client. 
     */
    public Connection getConnection(){
        return this.connection;
    }
    
    /**
     * Return method for the conference dialog window used for PM conferences 
     * with other users.
     * @return The conference dialog instance.  
     */
    public ConferenceDialog getConferenceDialog(){
        return this.conferenceDialog;
    }
    
    /**
     * Returns whether or not this client instance is currently connected to a 
     * server.  
     * @return True if this client is connected to a server, false otherwise.  
     */
    public boolean isConnected(){
        return this.isConnected;
    }

    /** 
     * Automatically generated code built from the Netbeans Swing functionality.
     * This method is called from within the constructor to
     * initialise the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        serverAddressLabel = new javax.swing.JLabel();
        serverAddress = new javax.swing.JTextField();
        connect = new javax.swing.JButton();
        conferenceScroll = new javax.swing.JScrollPane();
        conference = new javax.swing.JTextArea();
        send = new javax.swing.JButton();
        clear = new javax.swing.JButton();
        messageScroll = new javax.swing.JScrollPane();
        message = new javax.swing.JTextArea();
        lineBar = new javax.swing.JTextField();
        dataShare = new javax.swing.JButton();
        conferenceButton = new javax.swing.JButton();
        menuBar = new javax.swing.JMenuBar();
        connectionMenu = new javax.swing.JMenu();
        connectMenuItem = new javax.swing.JMenuItem();
        disconnectMenuItem = new javax.swing.JMenuItem();
        reconnectMenuItem = new javax.swing.JMenuItem();
        sep3 = new javax.swing.JPopupMenu.Separator();
        sendMenuItem = new javax.swing.JMenuItem();
        clearMenuItem = new javax.swing.JMenuItem();
        dataShareMenuItem = new javax.swing.JMenuItem();
        conferenceMenuItem = new javax.swing.JMenuItem();
        sep2 = new javax.swing.JPopupMenu.Separator();
        exitMenuItem = new javax.swing.JMenuItem();
        editMenu = new javax.swing.JMenu();
        saveMenuItem = new javax.swing.JMenuItem();
        sep1 = new javax.swing.JPopupMenu.Separator();
        preferencesMenuItem = new javax.swing.JMenuItem();
        aboutMenu = new javax.swing.JMenu();
        aboutMenuItem = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setTitle("Yarn Messenger");
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        setFont(new java.awt.Font("DejaVu Sans", 0, 15)); // NOI18N
        setLocationByPlatform(true);
        setMinimumSize(new java.awt.Dimension(540, 300));
        setName("frame"); // NOI18N
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        serverAddressLabel.setText("Server Address : ");

        serverAddress.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        serverAddress.setToolTipText("Server address bar");
        serverAddress.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                serverAddressKeyPressed(evt);
            }
            public void keyTyped(java.awt.event.KeyEvent evt) {
                serverAddressKeyTyped(evt);
            }
        });

        connect.setText("Connect");
        connect.setToolTipText("Connect/Disconnect");
        connect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                connectActionPerformed(evt);
            }
        });

        conferenceScroll.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        conferenceScroll.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        conference.setEditable(false);
        conference.setColumns(20);
        conference.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        conference.setLineWrap(true);
        conference.setRows(5);
        conference.setTabSize(4);
        conference.setToolTipText("Your current yarn text area");
        conference.setWrapStyleWord(true);
        conference.addCaretListener(new javax.swing.event.CaretListener() {
            public void caretUpdate(javax.swing.event.CaretEvent evt) {
                conferenceCaretUpdate(evt);
            }
        });
        conferenceScroll.setViewportView(conference);

        send.setText("Send");
        send.setToolTipText("Send");
        send.setAlignmentY(0.0F);
        send.setEnabled(false);
        send.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sendActionPerformed(evt);
            }
        });

        clear.setText("Clear");
        clear.setToolTipText("Clear");
        clear.setAlignmentY(0.0F);
        clear.setEnabled(false);
        clear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearActionPerformed(evt);
            }
        });

        messageScroll.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        messageScroll.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        message.setColumns(20);
        message.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        message.setLineWrap(true);
        message.setRows(2);
        message.setTabSize(4);
        message.setToolTipText("Send text area");
        message.setWrapStyleWord(true);
        message.setEnabled(false);
        message.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                messageKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                messageKeyReleased(evt);
            }
        });
        messageScroll.setViewportView(message);

        lineBar.setEditable(false);
        lineBar.setFont(new java.awt.Font("Tahoma", 0, 10)); // NOI18N
        lineBar.setToolTipText("Line count bar");

        dataShare.setText("Data Share");
        dataShare.setToolTipText("Data Share");
        dataShare.setAlignmentY(0.0F);
        dataShare.setEnabled(false);
        dataShare.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                dataShareActionPerformed(evt);
            }
        });

        conferenceButton.setText("Conference");
        conferenceButton.setToolTipText("Conference");
        conferenceButton.setAlignmentY(0.0F);
        conferenceButton.setEnabled(false);
        conferenceButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                conferenceButtonActionPerformed(evt);
            }
        });

        connectionMenu.setText("Connection");
        connectionMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                connectionMenuActionPerformed(evt);
            }
        });

        connectMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_C, java.awt.event.InputEvent.ALT_MASK));
        connectMenuItem.setText("Connect");
        connectMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                connectMenuItemActionPerformed(evt);
            }
        });
        connectionMenu.add(connectMenuItem);

        disconnectMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_D, java.awt.event.InputEvent.ALT_MASK));
        disconnectMenuItem.setText("Disconnect");
        disconnectMenuItem.setEnabled(false);
        disconnectMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                disconnectMenuItemActionPerformed(evt);
            }
        });
        connectionMenu.add(disconnectMenuItem);

        reconnectMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_R, java.awt.event.InputEvent.ALT_MASK));
        reconnectMenuItem.setText("Reconnect");
        reconnectMenuItem.setEnabled(false);
        reconnectMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                reconnectMenuItemActionPerformed(evt);
            }
        });
        connectionMenu.add(reconnectMenuItem);
        connectionMenu.add(sep3);

        sendMenuItem.setText("Send");
        sendMenuItem.setEnabled(false);
        sendMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sendMenuItemActionPerformed(evt);
            }
        });
        connectionMenu.add(sendMenuItem);

        clearMenuItem.setText("Clear");
        clearMenuItem.setEnabled(false);
        clearMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearMenuItemActionPerformed(evt);
            }
        });
        connectionMenu.add(clearMenuItem);

        dataShareMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Z, java.awt.event.InputEvent.ALT_MASK));
        dataShareMenuItem.setText("Data Share");
        dataShareMenuItem.setEnabled(false);
        dataShareMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                dataShareMenuItemActionPerformed(evt);
            }
        });
        connectionMenu.add(dataShareMenuItem);

        conferenceMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_X, java.awt.event.InputEvent.ALT_MASK));
        conferenceMenuItem.setText("Conference");
        conferenceMenuItem.setEnabled(false);
        conferenceMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                conferenceMenuItemActionPerformed(evt);
            }
        });
        connectionMenu.add(conferenceMenuItem);
        connectionMenu.add(sep2);

        exitMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_E, java.awt.event.InputEvent.ALT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        exitMenuItem.setText("Exit");
        exitMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitMenuItemActionPerformed(evt);
            }
        });
        connectionMenu.add(exitMenuItem);

        menuBar.add(connectionMenu);

        editMenu.setText("Edit");

        saveMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.ALT_MASK));
        saveMenuItem.setText("Save Yarn");
        saveMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveMenuItemActionPerformed(evt);
            }
        });
        editMenu.add(saveMenuItem);
        editMenu.add(sep1);

        preferencesMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_P, java.awt.event.InputEvent.ALT_MASK));
        preferencesMenuItem.setText("Preferences");
        preferencesMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                preferencesMenuItemActionPerformed(evt);
            }
        });
        editMenu.add(preferencesMenuItem);

        menuBar.add(editMenu);

        aboutMenu.setText("About");

        aboutMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_A, java.awt.event.InputEvent.ALT_MASK));
        aboutMenuItem.setText("About Yarn Messenger");
        aboutMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                aboutMenuItemActionPerformed(evt);
            }
        });
        aboutMenu.add(aboutMenuItem);

        menuBar.add(aboutMenu);

        setJMenuBar(menuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(messageScroll)
            .addComponent(conferenceScroll)
            .addGroup(layout.createSequentialGroup()
                .addComponent(serverAddressLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(serverAddress, javax.swing.GroupLayout.DEFAULT_SIZE, 299, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(connect, javax.swing.GroupLayout.PREFERRED_SIZE, 118, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(4, 4, 4))
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(send, javax.swing.GroupLayout.PREFERRED_SIZE, 90, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(clear, javax.swing.GroupLayout.PREFERRED_SIZE, 91, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(dataShare)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(conferenceButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(lineBar, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(serverAddressLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 18, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(connect, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(serverAddress, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(3, 3, 3)))
                .addComponent(conferenceScroll, javax.swing.GroupLayout.DEFAULT_SIZE, 220, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(messageScroll, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(clear, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(send, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lineBar, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(dataShare, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(conferenceButton, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Action event method for the clear button.  Clears the message text field 
     * of any entered text.  
     * @param evt The dialog event.
     */
    private void clearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearActionPerformed
        if (!this.message.getText().isEmpty())
            this.message.setText("");
        this.message.requestFocus();
    }//GEN-LAST:event_clearActionPerformed

    /**
     * Action event method for the connect/disconnect button.  This method is 
     * responsible for sending a connection request to the server and 
     * configuration the GUI to represent the connection, in other words enable 
     * certain components etc.  The same is true of a disconnect.  This method 
     * also contains a mechanism for preventing accidental double clicks or 
     * re-clicks resulting in a connect followed by an immediate disconnect or 
     * vice versa.  
     * @param evt The dialog event.  
     */
    private void connectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_connectActionPerformed

        this.connect.setEnabled(false);
        
        // If your disconnecting.
        if (this.isConnected){
            this.connection.disconnect();
            this.setSystemText(String.format("You have disconnected from %s",
                    this.serverAddress.getText()));
            this.setGUIToDisconnected();
            this.conferenceDialog.setVisible(false);
            this.isConnected = false;
        }
        
        // If your connecting.
        else if (!this.isConnected){
            if (!this.serverAddress.getText().equals("")){
                String address = this.serverAddress.getText();
                this.connection.connect(address);
                if (this.connection.isConnected()){
                    this.setGUIToConnected();
                    this.isConnected = true;
                }
            }
            else
                this.serverAddress.requestFocus();
        }
        
        /*
         * Prevent accidental button re-clicks by adding a small delay after 
         * the initial click. 
         */ 
        new Thread(new Runnable(){
            public void run(){
                try {
                    Thread.sleep(500);
                } catch (InterruptedException ex){}
                finally {
                    connect.setEnabled(true);
                }
            }
        }).start();
    }//GEN-LAST:event_connectActionPerformed

    /**
     * Action event method for the send button.  This method is responsible for 
     * sending text to the server and therefore other clients.  Different typed 
     * text results in different functionality.  For example if '-h' or '-help' 
     * is typed by the user then the help message text is displayed.  If a data 
     * share command is typed then the data share process begins with 
     * validation.  
     * @param evt The dialog event.  
     */
    private void sendActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sendActionPerformed

        String text = this.message.getText().trim();
        this.message.setText("");
        
        if (text.isEmpty()){ 
            // Do nothing.
        }
        else if (text.equals("-h") || text.equals("-help")){
            this.setSystemText(Configuration.HELP_MSG);
        }
        else if ((text.startsWith("@") && text.contains(ReceiveThread.FILE_SHARE_SEND_CMD)) ||
                 (text.startsWith("@") && text.contains(ReceiveThread.VOICE_SHARE_SEND_CMD))){
            this.setSentText(text);
            // Alerts the user if a share is sent. Validation occurs first.
            this.connection.sendShareRequestAndData(text);
            this.setLastPMUsernames(text);
            this.lastSentText = text;
        }
        else if (this.isConnected){
            this.setSentText(text);
            this.connection.send(text);
            this.setLastPMUsernames(text);
            this.lastSentText = text;
        }
        else if (!this.isConnected){
            this.setSystemText("Connect to server first");
        }

        this.message.requestFocus();
    }//GEN-LAST:event_sendActionPerformed

    /**
     * Not used.  
     * @param evt 
     */
    private void serverAddressKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_serverAddressKeyTyped
        // Not used.
    }//GEN-LAST:event_serverAddressKeyTyped

    /**
     * Action method for when a key is pressed whilst the message text field has 
     * focus. The enter key results in the send button being clicked providing 
     * the configuration is setup to do so.  The escape key clears the text from 
     * send text field.  The up arrow replaces the current text field message 
     * with the last sent text while the down arrow pastes the last username(s) 
     * entered into the text field.  
     * @param evt The dialog event.  
     */
    private void messageKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_messageKeyPressed
        int keyCode = evt.getKeyCode();
        if (keyCode == KeyEvent.VK_ENTER && Configuration.enterSend)
            this.send.doClick();
        else if (keyCode == KeyEvent.VK_ESCAPE)
            this.clear.doClick();
        else if (keyCode == KeyEvent.VK_UP){
            if (!this.lastSentText.isEmpty())
                this.message.setText(this.lastSentText);
        }
        else if (keyCode == KeyEvent.VK_DOWN){
            if (!this.lastPMUsernames.equals(""))
                this.message.setText(this.lastPMUsernames);
        }
    }//GEN-LAST:event_messageKeyPressed

    /**
     * Action method for when a key is release whilst the message text field 
     * has focus.  If the released key is the return key and the configuration 
     * is setup to send text when return is released then the send button is 
     * clicked.  
     * @param evt The dialog event.  
     */
    private void messageKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_messageKeyReleased
        int keyCode = evt.getKeyCode();
        if (keyCode == KeyEvent.VK_ENTER && Configuration.enterSend)
            this.message.setText("");
    }//GEN-LAST:event_messageKeyReleased

    /**
     * Action method for when a key is pressed whilst the server address text 
     * field has focus.  The return key results in the connect button being 
     * clicked while the escape key clears any text.  
     * @param evt The dialog event.  
     */
    private void serverAddressKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_serverAddressKeyPressed
        int keyCode = evt.getKeyCode();
        if (keyCode == KeyEvent.VK_ENTER){
            this.connect.doClick();
            this.message.requestFocus();
        }
        else if (keyCode == KeyEvent.VK_ESCAPE && this.serverAddress.isEditable())
            this.serverAddress.setText("");
    }//GEN-LAST:event_serverAddressKeyPressed

    /**
     * Action method for the connect menu item.  When clicked the connect button 
     * is clicked in turn.  
     * @param evt The dialog event.  
     */
    private void connectMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_connectMenuItemActionPerformed
        if (!this.isConnected)
            this.connect.doClick();
    }//GEN-LAST:event_connectMenuItemActionPerformed

    /**
     * Action method for the disconnect menu item.  When clicked the connect 
     * button is clicked in turn.  The connect button text will of course have 
     * changed to "Disconnect" however.  
     * @param evt The dialog event.  
     */
    private void disconnectMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_disconnectMenuItemActionPerformed
        if (this.isConnected)
            this.connect.doClick();
    }//GEN-LAST:event_disconnectMenuItemActionPerformed

    /**
     * Action method for the reconnect menu item.  When clicked the connect 
     * button is clicked twice in turn effectively disconnecting and then 
     * reconnecting the client to the server.  A delay between the clicks is 
     * implemented for separation of events.  If already disconnected then this 
     * method simply clicks the connect once to connect to the server.  
     * @param evt The dialog event.  
     */
    private void reconnectMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_reconnectMenuItemActionPerformed
        // Disconnect then connect.
        if (this.isConnected){
            this.connect.doClick();
            try {
                Thread.sleep(600); // This delays is slightly more than the 'Connect' button click delay.
            } 
            catch (InterruptedException ex){}
            this.connect.doClick();
        }
        // Just connect.
        else
            this.connect.doClick();
    }//GEN-LAST:event_reconnectMenuItemActionPerformed

    /**
     * Action method for the exit menu item.  When clicked the formWindowClosing 
     * method is called.  This method initiates the shutdown of the client.  
     * @param evt The dialog event.  
     */
    private void exitMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitMenuItemActionPerformed
        formWindowClosing(new WindowEvent(this, 1));
    }//GEN-LAST:event_exitMenuItemActionPerformed

    /**
     * Action method for the about menu item.  When clicked the about dialog is 
     * displayed to user.  This dialog contains information about the 
     * communication system.  
     * @param evt The dialog event.  
     */
    private void aboutMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_aboutMenuItemActionPerformed
        this.showAboutDialog();
    }//GEN-LAST:event_aboutMenuItemActionPerformed

    /**
     * Action method for the preferences menu item.  When clicked a new 
     * preferences dialog instance is initialised (if necessary) displaying the 
     * preferences dialog to the user.  From here the user can configure the 
     * client to suit their needs.  
     * @param evt The dialog event.  
     */
    private void preferencesMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_preferencesMenuItemActionPerformed
        try {
            if (!this.preferencesDialog.isVisible())
                this.preferencesDialog = new PreferencesDialog(this);
            else
                this.preferencesDialog.requestFocus();
        }
        catch (NullPointerException npe){
            this.preferencesDialog = new PreferencesDialog(this);
        }
    }//GEN-LAST:event_preferencesMenuItemActionPerformed

    /**
     * Action method for when the cursor is moved within the conference text 
     * area.  The result is an update of the line count in the bottom right of 
     * the main GUI dialog instance.  
     * @param evt The dialog event.  
     */
    private void conferenceCaretUpdate(javax.swing.event.CaretEvent evt) {//GEN-FIRST:event_conferenceCaretUpdate
        // Get the current line count and display to user in the line bar.
        int pos = this.conference.getCaretPosition();
        try {
            int line = this.conference.getLineOfOffset(pos);
            line++;
            this.lineBar.setText("Line(s) " + line);
        }
        catch (Exception ex){
            this.lineBar.setText("Line(s) ");
        }
    }//GEN-LAST:event_conferenceCaretUpdate

    /**
     * Action method for the exit menu item.  When clicked the system will 
     * disconnect if necessary (with user permission) and shutdown the client 
     * causing the GUI to disappear.  
     * @param evt The dialog event.  
     */
    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        if (this.isConnected()){
            int result = this.showDisconnectAndExitDialog();
            if (result == JOptionPane.YES_OPTION){
                this.disconnectDoClick();
                System.exit(0);
            }
            // Else continue with connected yarn.
        }
        else {
            System.exit(0);
        }
    }//GEN-LAST:event_formWindowClosing

    /**
     * Action method for the clear menu item.  When clicked the clear button is 
     * clicked resulting the message field text being cleared.  
     * @param evt The dialog event.  
     */
    private void clearMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearMenuItemActionPerformed
        this.clear.doClick();
    }//GEN-LAST:event_clearMenuItemActionPerformed

    /**
     * Action method for the send menu item.  When clicked the send button is 
     * clicked in turn.  
     * @param evt The dialog event.  
     */
    private void sendMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sendMenuItemActionPerformed
        this.send.doClick();
    }//GEN-LAST:event_sendMenuItemActionPerformed

    /**
     * Action method for the data share button.  The button click results in a 
     * share dialog instance being initialised (if necessary) displaying the 
     * data share dialog to the user.  
     * @param evt The dialog event.  
     */
    private void dataShareActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_dataShareActionPerformed
        if (this.shareDialog == null || !this.shareDialog.isVisible())
            this.shareDialog = new ShareDialog(this);
        else
            this.shareDialog.requestFocus();
    }//GEN-LAST:event_dataShareActionPerformed

    /**
     * Action method for the data share menu item.  When clicked the data share 
     * button is clicked in turn.  
     * @param evt The dialog event.  
     */
    private void dataShareMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_dataShareMenuItemActionPerformed
        this.dataShare.doClick();
    }//GEN-LAST:event_dataShareMenuItemActionPerformed

    /**
     * Action method for the save menu item.  When clicked the save yarn method 
     * is called.  This method enables the user to save the current conference 
     * text.  
     * @param evt The dialog event.  
     */
    private void saveMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveMenuItemActionPerformed
        this.saveYarn();
    }//GEN-LAST:event_saveMenuItemActionPerformed

    /**
     * Action method for the conference button.  When clicked the conference 
     * dialog is displayed to the user.  
     * @param evt The dialog event.  
     */
    private void conferenceButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_conferenceButtonActionPerformed
        this.conferenceDialog.setVisible(true);
    }//GEN-LAST:event_conferenceButtonActionPerformed

    /**
     * Not used.  
     * @param evt 
     */
    private void connectionMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_connectionMenuActionPerformed
        // Not used.
    }//GEN-LAST:event_connectionMenuActionPerformed

    /**
     * Action method for the conference menu item.  When clicked the conference 
     * button is clicked in turn displaying the conference dialog to the user.  
     * @param evt The dialog event.  
     */
    private void conferenceMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_conferenceMenuItemActionPerformed
        this.conferenceButton.doClick();
    }//GEN-LAST:event_conferenceMenuItemActionPerformed

    /**
     * Displays the main GUI dialog window to the user.  The class constructor 
     * is called automatically before this method, therefore the GUI 
     * initialisation is done by the constructor.  
     * @param args Not used due to the use of an event driven GUI.  
     */
    public static void main(String args[]) {
        // Display GUI to user on startup.
        java.awt.EventQueue.invokeLater(new Runnable(){
            public void run() {
                new GUI().setVisible(true);
            }
        });
    }
    
    /**
     * This method is responsible for the entering of text into the send text 
     * field and the clicking of the send button effectively replicating a user 
     * 'send'.  
     * @param text The text to be 'typed' and sent to the server.  
     */
    public void enterAndSendText(String text){
        this.message.setText(text);
        this.send.doClick();
    }

    /**
     * This method displays the sent text in the main text pane. All sent text 
     * is prepended with --> and is appended with a new line break.  The line 
     * break sets the next sent text to be printed on a new line.  This method 
     * is obviously called when the user sends text to the server.  
     * @param text The sent text which is to be displayed in the main text 
     * pane to the user.
     */
    private synchronized void setSentText(String text){
        text = text.trim();
        this.conference.append("--> " + text + "\n");
        this.scrollConferenceToBottom();
    }

    /**
     * This method works the same as setSentText(String) except system text is 
     * not prepended with --> in the same way.  This method is used when the 
     * system wants to alert the user about something. 
     * @param text The system text to be displayed to the user.
     */
    public final synchronized void setSystemText(String text){
        // Append the text and scroll to the bottom of the conference window.
        // NOTE: Don't trim the text here as it'll remove any \n in the text.
        this.conference.append(text + "\n");
        this.scrollConferenceToBottom();
    }
    
    /**
     * This method works the same as setSentText(String) except its for 
     * displaying text to the user which has been received from other clients 
     * through the server.  The only difference between this method and 
     * setSystemText is that an alert noise is also played when received text is 
     * displayed to the user.  This alert functionality can be turned off in the 
     * configuration if desired by the user.  
     * @param text The received text which is to be displayed to the user. 
     */
    public final synchronized void setReceivedText(String text){
        Utilities.delay(100);
        // Append the text and scroll to the bottom of the conference window.
        this.conference.append(text + "\n");
        this.scrollConferenceToBottom();
        // If the GUI is NOT in focus when a msg is received then play a sound.
        if (!this.isInFocus() && Configuration.soundAlert)
            GUI.playAlertSound();
    }

    /**
     * This method is responsible for firstly extracting the usernames from the 
     * text being sent to the server.  The list of usernames is then made into 
     * a string and set as an instance variable.  The usernames can be pasted 
     * into the send text area when necessary if the user presses the down key. 
     * @param text The text being sent which contains at least one username 
     * prepended with an @ symbol.  
     */
    private void setLastPMUsernames(String text){
        if (!text.trim().startsWith("@")) return;
        String unames = "";
	do {
            int space = text.indexOf(" ");
            String uname;
            try { uname = text.substring(0, space); }
            catch (Exception ex){ return; }
            unames += (uname + " ");
            text = text.substring(space + 1);
        }
        while (text.trim().startsWith("@"));
        this.lastPMUsernames = unames;
    }

    /**
     * This method clicks the connect button if disconnected simulating a user 
     * click.  
     */
    public synchronized void connectDoClick(){
        if (!this.isConnected())
            this.connect.doClick();
    }
    
    /**
     * This method clicks the disconnect button if connected simulating a user 
     * click.  
     */
    public synchronized void disconnectDoClick(){
        if (this.isConnected())
            this.connect.doClick();
    }

    /**
     * This method configures the main GUI dialog and its graphical components 
     * to show a connection to the server.  For example the connect button text 
     * is changed to "Disconnect" for obvious reasons.  
     */
    private void setGUIToConnected(){
        // GUI components.
        this.connect.setText(" Disconnect ");
        this.serverAddress.setEditable(false);
        this.send.setEnabled(true);
        this.clear.setEnabled(true);
        this.dataShare.setEnabled(true);
        this.conferenceButton.setEnabled(true);
        // Menu items.
        this.connectMenuItem.setEnabled(false);
        this.disconnectMenuItem.setEnabled(true);
        this.reconnectMenuItem.setEnabled(true);
        this.message.setEnabled(true);
        this.sendMenuItem.setEnabled(true);
        this.clearMenuItem.setEnabled(true);
        this.dataShareMenuItem.setEnabled(true);
        this.conferenceMenuItem.setEnabled(true);
        // Request focus.
        this.message.requestFocus();
    }
    
    /**
     * This method configures the main GUI dialog and its graphical components 
     * to show a disconnection to the server.  For example the connect button 
     * text is changed to "Connect" for obvious reasons.  
     */
    private void setGUIToDisconnected(){
        // GUI components.
        this.connect.setText("   Connect    ");
        this.serverAddress.setEditable(true);
        this.send.setEnabled(false);
        this.clear.setEnabled(false);
        this.dataShare.setEnabled(false);
        this.conferenceButton.setEnabled(false);
        // Menu items.
        this.connectMenuItem.setEnabled(true);
        this.disconnectMenuItem.setEnabled(false);
        this.reconnectMenuItem.setEnabled(false);
        this.message.setEnabled(false);
        this.sendMenuItem.setEnabled(false);
        this.clearMenuItem.setEnabled(false);
        this.dataShareMenuItem.setEnabled(false);
        this.conferenceMenuItem.setEnabled(false);
        // Request focus.
        this.serverAddress.requestFocus();
    }
    
    /**
     * This method scrolls to the top of the conference text area pane.
     */
    private void scrollConferenceToTop(){
        this.conference.select(this.conference.getHeight() - 10000000, 0);
    }
    
    /**
     * This method scrolls to the bottom of the conference text area pane.
     */
    private void scrollConferenceToBottom(){
        this.conference.select(this.conference.getHeight() + 10000000, 0);
    }
    
    /**
     * This method allows the user to save the text currently contained in the 
     * conference text area at the time of the method call.  This is done using 
     * the Java showSaveFileDialog() method to select a file location.  The 
     * conference text area contents are saved as a plain text file.  
     */
    private void saveYarn(){
        // Graphically allow user to create a new file in a directory.
        File file = this.showSaveFileDialog();
        try {
            // Save selected file.
            FileWriter fileWriter = new FileWriter(file);
            BufferedWriter output = new BufferedWriter(fileWriter);
            // Save text to the created file.
            output.write(this.conference.getText());
            output.close();
        }
        catch (NullPointerException npe){
            // Do nothing when 'save as' dialog is cancelled.
        }
        catch (IOException ioe){
            // Never seems to occur.
            this.setSystemText(ioe.getMessage());
        }
    }

    /**
     * This method uses the Java JOptionPane static method to display useful 
     * 'about' information.  
     */
    private void showAboutDialog(){
        String text =
                "Yarn Messenger " + Configuration.VERSION + "\n" +
                "The instant messenger without restrictions!\n\n" +
                "Powered by Java, Developed by Michael Telford\n" +
                "Visit http://www.yarn.co.uk for more information";
        JOptionPane.showMessageDialog(this, text,
                "About Yarn Messenger", JOptionPane.INFORMATION_MESSAGE);
    }
    
    /**
     * This method uses the Java JOptionPane static method to display a yes or 
     * no choice to the user about whether or not to disconnect from a server 
     * and exit the application.  
     * @return An integer value representing the yes or no user response.  
     */
    private int showDisconnectAndExitDialog(){
        String text =
                "You are currently connected to a Yarn Server...\n\n"
                + "Do you want to disconnect now and exit??";
        return JOptionPane.showConfirmDialog(this, text,
                "Client is connected to server", JOptionPane.YES_NO_OPTION);
    }
    
    /**
     * This method uses the Java JFileChooser class to display a save file 
     * dialog to the user.  
     * @return The user selected file.  
     */
    private File showSaveFileDialog(){
        JFileChooser fileChooser = new JFileChooser();
        int result = fileChooser.showSaveDialog(this);
        if (result == JFileChooser.APPROVE_OPTION){
            File file = fileChooser.getSelectedFile();
            return file;
        }
        else
            return null;
    }
    
    /**
     * This method uses the Java JOptionPane static method to display an OK 
     * choice to the user about using the default configuration values most 
     * likely because the configuration file cannot be located.  
     */
    public static void showUsingDefaultConfigValuesDialog(){
        String text =
            "Yarn Messenger can't locate the configuration file\nwhich it"
            + " needs, or the config file isn't formatted correctly\n" 
            + "Yarn is preceding with default values instead\n"
            + "Check the Preferences menu for details";
        JOptionPane.showMessageDialog(GUI.serverAddressLabel, text,
                "Missing/Incorrect Configuration File", JOptionPane.OK_OPTION);
    }
    
    /**
     * This method uses the Java JOptionPane static method to display an OK 
     * choice to the user about not being able to save the configuration values 
     * most likely because the configuration file cannot be located or an XML 
     * format error has occurred.  
     */
    public static void showCannotSaveConfigChangesDialog(){
        String text =
            "Yarn Messenger can't locate the configuration file which it"
            + " needs,\nor the config file isn't formatted correctly\n" 
            + "All/some of your changes may not take effect on next start up";
        JOptionPane.showMessageDialog(GUI.serverAddressLabel, text,
                "Cannot Save Configuration Changes", JOptionPane.OK_OPTION);
    }
    
    /**
     * This method uses the Java JDialog class to display a data share request 
     * dialog to the user for a given time frame.  The request details the 
     * various pieces of data share information such as the sending user and 
     * data size etc.  The user can select yes or no to the question of "Do you 
     * wish to accept the data share?" etc.  If the timeout expires the then 
     * default answer of no is used.
     * @param msg The data share request message.  
     * @return True if the user clicks yes and accepts the data share, false 
     * otherwise.  
     */
    public boolean showDataShareRequestDialog(String msg){
        final JOptionPane optionPane = new JOptionPane(msg, 
                                                       JOptionPane.QUESTION_MESSAGE,
                                                       JOptionPane.YES_NO_OPTION);
        final JDialog dialog = new JDialog(this, "Data Share Request", true);
        dialog.setContentPane(optionPane);
        dialog.setDefaultCloseOperation(JDialog.HIDE_ON_CLOSE);
        dialog.pack();
        dialog.setResizable(false);
        this.setDialogPosition(dialog);
        
        optionPane.addPropertyChangeListener(
            new PropertyChangeListener(){
                public void propertyChange(PropertyChangeEvent e){
                    String prop = e.getPropertyName();
                    if (dialog.isVisible() 
                     && (e.getSource() == optionPane)
                     && (prop.equals(JOptionPane.VALUE_PROPERTY))){
                        dialog.setVisible(false);
                    }
                }
            });
        
        Thread dialogTimerThread = new Thread(new Runnable(){
            public void run(){
                int timeoutInSeconds = 10;
                Utilities.delay(timeoutInSeconds * 1000);
                if (dialog.isVisible()){
                    dialog.dispose();
                }
            }
        });
        
        dialogTimerThread.start();
        dialog.setVisible(true);
        
        int value;
        try {
            value = ((Integer)optionPane.getValue()).intValue();
        }
        catch (ClassCastException cce){
            // Reject the data share if the user closes the dialog by clicking
            // the red X or if the dialog timer thread disposes of the dialog.
            return false;
        }
        // Determine if the user clicked Yes or No.
        if (value == JOptionPane.YES_OPTION)
            return true;
        else
            return false;
    }
    
    /**
     * This method is responsible for setting the dialog position for the given 
     * component parameter.  The position is set based on this main GUI instance 
     * acting as the parent component.  In other words the component is 
     * positioned 'on top' of this main GUI instance.  
     * @param comp The component which is to be positioned on top of this main 
     * GUI instance.  
     */
    public void setDialogPosition(Component comp){
        Point pos = this.getLocation();
        int px = (int)(pos.getX());
        int py = (int)(pos.getY());
        int x  = (px + (this.getWidth() / 2)  - (comp.getWidth() / 2));
        int y  = (py + (this.getHeight() / 2) - (comp.getHeight() / 2));
        Point newPos = new Point(x, y);
        comp.setLocation(newPos);
    }
    
    /**
     * This method returns whether or not this dialog in currently in focus.
     * @return True if in focus, false otherwise. 
     */
    private boolean isInFocus(){
        if (this.hasFocus()
         || this.getContentPane().hasFocus()
         || this.serverAddress.hasFocus() 
         || this.connect.hasFocus()
         || this.conference.hasFocus()
         || this.message.hasFocus()
         || this.send.hasFocus()
         || this.clear.hasFocus()
         || this.connectMenuItem.hasFocus()
         || this.disconnectMenuItem.hasFocus()
         || this.reconnectMenuItem.hasFocus()
         || this.sendMenuItem.hasFocus()
         || this.clearMenuItem.hasFocus()
         || this.exitMenuItem.hasFocus()
         || this.menuBar.hasFocus()
         || this.connectionMenu.hasFocus()
         || this.editMenu.hasFocus()
         || this.aboutMenu.hasFocus())
            return true;
        else
            return false;
    }
    
    /**
     * This method disables certain dialog components for when a data share 
     * is taking place.  This disables the users ability to send text along 
     * with the data share until the server has received the data. 
     * @param isEnabled True for enabled functionality, false for disabled 
     * functionality of certain components within this dialog. 
     */
    public void setGUISendAbility(boolean isEnabled){
        this.send.setEnabled(isEnabled);
        this.sendMenuItem.setEnabled(isEnabled);
        this.dataShare.setEnabled(isEnabled);
        this.dataShareMenuItem.setEnabled(isEnabled);
        this.conferenceDialog.setGUISendAbility(isEnabled);
    }
    
    /**
     * This method is responsible for playing the alert sound.  The alert sound 
     * is typically played when text has been received from the server and the 
     * main GUI dialog instance isn't currently in focus.  
     */
    public static synchronized void playAlertSound(){
        URL soundFilePath = GUI.class.getResource("alert.wav");
        try {
            InputStream input = new FileInputStream(soundFilePath.getFile());
            AudioStream audioStream = new AudioStream(input); 
            AudioPlayer.player.start(audioStream);
        } 
        catch (Exception ex){
            //System.out.println("Play Alert Sound Exception: " + ex.getLocalizedMessage());
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu aboutMenu;
    private javax.swing.JMenuItem aboutMenuItem;
    private javax.swing.JButton clear;
    private javax.swing.JMenuItem clearMenuItem;
    public javax.swing.JTextArea conference;
    private javax.swing.JButton conferenceButton;
    private javax.swing.JMenuItem conferenceMenuItem;
    private javax.swing.JScrollPane conferenceScroll;
    private javax.swing.JButton connect;
    private javax.swing.JMenuItem connectMenuItem;
    private javax.swing.JMenu connectionMenu;
    private javax.swing.JButton dataShare;
    private javax.swing.JMenuItem dataShareMenuItem;
    private javax.swing.JMenuItem disconnectMenuItem;
    private javax.swing.JMenu editMenu;
    private javax.swing.JMenuItem exitMenuItem;
    private javax.swing.JTextField lineBar;
    private javax.swing.JMenuBar menuBar;
    private javax.swing.JTextArea message;
    private javax.swing.JScrollPane messageScroll;
    private javax.swing.JMenuItem preferencesMenuItem;
    private javax.swing.JMenuItem reconnectMenuItem;
    private javax.swing.JMenuItem saveMenuItem;
    private javax.swing.JButton send;
    private javax.swing.JMenuItem sendMenuItem;
    private javax.swing.JPopupMenu.Separator sep1;
    private javax.swing.JPopupMenu.Separator sep2;
    private javax.swing.JPopupMenu.Separator sep3;
    public javax.swing.JTextField serverAddress;
    private static javax.swing.JLabel serverAddressLabel;
    // End of variables declaration//GEN-END:variables
}